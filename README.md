# Ticketmaster Test Application

A PROJECT TO LEARN HELIDON AND COMPLETE A TICKETMASTER TEST

THINGS TO DO: 
- CHANGE DIR STRUCTURE (THIS WAS GENERATED BY HELIDON)
- ADD NGINX AND INGRESS SPECIFICATIONS
- ADD ERROR HANDLERS AND MORE ROBUSTNESS INTO JAVA CODE
- ADD SOME CUSTOM METRICS SUCH A HISTOGRAMS INCLUDING RANDOM COUNTS

## Assignment

Develop a webservice in your favourite language it should implement the following methods:

8080
- "/add" : f(n1, n2) = n1 + n2
- "/subtract" : f(n1, n2) = n1 - n2
- "/division" : f(n1, n2) = n1 / n2
- "/random" : (count? = 10) = Math.random() times count

8081
- "/metrics" : prometheus metrics endpoint for scrapping

8082
- "/readiness": 200
- "/liveness":  200

## Build and run

With JDK11+

```bash
mvn package
java -jar target/tm-testy-se.jar
```

## Exercise the application

```
curl -X GET -H "Content-Type: application/json" -d '[20, 10]' http://localhost:8080/add
curl -X GET -H "Content-Type: application/json" -d '[20, 10]' http://localhost:8080/subtract
curl -X GET -H "Content-Type: application/json" -d '[20, 10]' http://localhost:8080/division
curl -X GET -H "Content-Type: application/json" -d '{}' http://localhost:8080/random
curl -X GET -H "Content-Type: application/json" -d '{"count" : 5}' http://localhost:8080/random

```

## Build the Docker Image

```
docker build -t tm-testy-se .
```

## Start the application with Docker

```
docker run --rm -p 8080:8080 tm-testy-se:latest
```

Exercise the application as described above

## Deploy the application to Kubernetes

```
minikube start                              # local cluster (or use alternative)
kubectl cluster-info                        # Verify which cluster
kubectl get pods                            # Verify connectivity to cluster
kubectl create -f app.yaml                  # Deploy application
kubectl get pods                            # Wait for quickstart pod to be RUNNING
kubectl get service helidon-quickstart-se   # Get service info
```

Note the PORTs. You can now exercise the application as you did before but use the second
port number (the NodePort) instead of 8080.

After youâ€™re done, cleanup.

```
kubectl delete -f app.yaml
```

## Build a native image with GraalVM

GraalVM allows you to compile your programs ahead-of-time into a native
executable. See https://www.graalvm.org/docs/reference-manual/aot-compilation/
for more information.

You can build a native executable in 2 different ways:

* With a local installation of GraalVM
* Using Docker

### Local build

Download Graal VM at https://www.graalvm.org/downloads, the versions
currently supported for Helidon are `20.1.0` and above.

```
# Setup the environment
export GRAALVM_HOME=/path
# build the native executable
mvn package -Pnative-image
```

You can also put the Graal VM `bin` directory in your PATH, or pass
`-DgraalVMHome=/path` to the Maven command.

See https://github.com/oracle/helidon-build-tools/tree/master/helidon-maven-plugin#goal-native-image
for more information.

Start the application:

```
./target/tm-testy-se
```

### Multi-stage Docker build

Build the "native" Docker Image

```
docker build -t tm-testy-se-native -f Dockerfile.native .
```

Start the application:

```
docker run --rm -p 8080:8080 tm-testy-se-native:latest
```

## Build a Java Runtime Image using jlink

You can build a custom Java Runtime Image (JRI) containing the application jars and the JDK modules
on which they depend. This image also:

* Enables Class Data Sharing by default to reduce startup time.
* Contains a customized `start` script to simplify CDS usage and support debug and test modes.

You can build a custom JRI in two different ways:

* Local
* Using Docker

### Local build

```
# build the JRI
mvn package -Pjlink-image
```

See https://github.com/oracle/helidon-build-tools/tree/master/helidon-maven-plugin#goal-jlink-image
for more information.

Start the application:

```
./target/tm-testy-se-jri/bin/start
```

### Multi-stage Docker build

Build the JRI as a Docker Image

```
docker build -t tm-testy-se-jri -f Dockerfile.jlink .
```

Start the application:

```
docker run --rm -p 8080:8080 tm-testy-se-jri:latest
```

See the start script help:

```
docker run --rm tm-testy-se-jri:latest --help
```
